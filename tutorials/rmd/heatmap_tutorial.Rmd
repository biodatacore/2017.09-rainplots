---
title: "heatmaps Tutorial"
author: "Mir Henglin"
date: "June 25, 2019"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.height = 10, fig.width = 10, fig.align = "center")
```

```{r data_intro, child = 'tdi4.Rmd'}
```

```{r nl10pv, child = 'nl10pv.Rmd'}
```

## Plotting

A basic heatmap can be constructed in just two lines of `ggplot2` code!

```{r}

heatmap <-
  ggplot(plot_data) +
  geom_tile(aes(x = response, y = term, fill = p.value))

heatmap
```

This is a good start, but wewant to clean up layout and presentation. We can do this by creating a custom `ggplot2` and adjusting scales. 

```{r}

thm <- 
  # Good starting theme + set text size
  theme_light(base_size = 18) +
  theme(
    # Remove axis ticks and titles
    axis.title.x = element_blank(),
    axis.ticks.x = element_blank(),
    axis.title.y = element_blank(),
    axis.ticks.y = element_blank(),
    
    # Remove boxes
    axis.line = element_blank(),
    legend.key = element_blank(),
    
    # Angle text
    axis.text.x.top  = element_text(angle = 45, hjust = 0)
  ) 

heatmap <- 
  heatmap + 
  thm + 
  # Move x-axis label to top of plot
  scale_x_discrete(position = 'top') +
  # Better legend title
  scale_fill_continuous(expression(paste(-log[10]('P-value')))) 


heatmap


```

We can improve the color perception by using  a 'viridis' colour palette.

```{r}

heatmap <- 
  heatmap + 
  scale_fill_viridis_c(
    expression(paste(-log[10]('P-value')))
  )

heatmap


```

In addition to displaying information about P-values, a heatmap can be used to display information about effect size estimates. For the effect size heatmap, we use a diverging red-blue color palette. In order to guarentee a symmetric palette, we set the limits based on our data.

```{r}

palette <-
  c("#053061",
    "#313695",
    "#4575b4",
    "#74add1",
    "#abd9e9",
    "#e0f3f8",
    "#fee090",
    "#fdae61",
    "#f46d43",
    "#d73027",
    "#a50026",
    '#67001f')

# Calculate symetiric limits based on most extreme value
max_abs_estimate <- max(abs(plot_data$estimate))

max_lim <- max_abs_estimate
min_lim = -1 * max_lim

```

```{r}
heatmap <-
  ggplot(plot_data) +
  geom_tile(aes(x = response, y = term, fill = estimate)) +
  thm + 
  scale_x_discrete(position = 'top') +
  scale_fill_gradientn(
    'Effect Size Estimate',
    colors = palette,
    limits = c(min_lim, max_lim),
    breaks = c(min_lim,  min_lim / 2, 0 , max_lim/2, max_lim)
  )

heatmap
```

## Additional Plot Adjustments

### P-value Thresholding

When a few P-values are much smaller than the majority of the data, a P-value heatmap loses color resolution in the range where most of the data lies. One possible solution is to set all P-values above some ceiling, here chosen to be 15, to the value of the ceiling. The threshold can be set at a level where one considers all P-values more extreme than the threshold to be 'of interest'.

```{r}

plot_data_thresholded <- 
  plot_data %>% 
  mutate(p.value = ifelse(p.value > 15, 15, p.value))

heatmap <-
  # Use the thresholded data
  ggplot(plot_data_thresholded) +
  geom_tile(aes(x = response, y = term, fill = p.value)) + 
  scale_x_discrete(position = 'top') +
  # Set the legend breaks and labels to account for the thresholding
  scale_fill_viridis_c(
    expression(paste(-log[10]('P-value'))),
    breaks = c(0, 5, 10, 15), 
    labels = c('0', '5', '10', '>=15')
  ) +
  thm


heatmap
```

### Ordering by P-Value

To make it easier to identify the metabolites that had small P-values in multiple models, we will convert the `term` column into a factor variable ordered by the average P-value across all models. This will put metabolites with small P-values in multiples models at the top of the plot, and metabolites with large P-values in multiple models at the bottom of the plot. Once the `term` column has been converted, both P-value and effect estimate heatmaps will have the same order.

```{r}
# Order metabolites by average p-value
term_order <-
  plot_data %>% 
  group_by(term) %>% 
  summarise(mpv = mean(p.value)) %>% 
  arrange(mpv) %>% 
  pull(term)

# Convert term to a factor, ordered by `term_order`
plot_data_pvo <- 
  plot_data %>% 
  mutate(term = factor(term, levels = term_order))
```

```{r}
heatmap_base <- 
  # Use the data with the term column ordered by mean P-value
  ggplot(plot_data_pvo) +
  scale_x_discrete(position = 'top') +
  thm

pv_heatmap_pvo <-
  heatmap_base +
  geom_tile(aes(x = response, y = term, fill = p.value)) + 
  scale_fill_viridis_c(
    expression(paste(-log[10]('P-value')))
  ) 


pv_heatmap_pvo

es_heatmap_pvo <-
  heatmap_base +
  geom_tile(aes(x = response, y = term, fill = estimate)) +
  scale_fill_gradientn(
    'Effect Size Estimate',
    colors = palette,
    limits = c(min_lim, max_lim),
    breaks = c(min_lim,  min_lim / 2, 0 , max_lim/2, max_lim)
  ) 

es_heatmap_pvo

```

### Ordering by Cluster

Heatmaps can be ordered by cluster such that similar depdendent variable terms are plotted next to one another. We will be using the `hculst` function to cluster the results by effect size estimate. The `term` variable will be converted into an ordered factor, such that clustered terms are plotted next to one another. In order to cluster the data, we will need to reshape it using the spread function from the `tidyr` package. Once the `term` column has been converted, both P-value and effect size estimate heatmaps will have the same order.

```{r, warning=FALSE, message=FALSE}
library(tidyr)
```

```{r}
# Convert to matrix and reshape for clustering.
cluster_data <-
  plot_data %>% 
  select(response, term, estimate) %>% 
  spread(response, estimate)

rnms <- 
  cluster_data$term

cluster_data <-
  cluster_data %>% 
  select(-term) %>% 
  as.matrix()

rownames(cluster_data) <- rnms

cluster_data[1:5, 1:5]
```

```{r}
clust <- hclust(dist(cluster_data), method = 'ward.D2')
```


```{r}

# `clust$order` orders `term` into clusters
term_order <-
  clust$labels[clust$order]

# Convert term to a factor, ordered by `term_order`
plot_data_clo <- 
  plot_data %>% 
  mutate(term = factor(term, levels = term_order))
```

```{r}

heatmap_base <- 
  # Use cluter ordered data
  ggplot(plot_data_clo) +
  scale_x_discrete(position = 'top') +
  thm

pv_heatmap_clo <-
  heatmap_base +
  geom_tile(aes(x = response, y = term, fill = p.value)) + 
  scale_fill_viridis_c(
    expression(paste(-log[10]('P-value')))
  ) 


pv_heatmap_clo

es_heatmap_clo <- 
  heatmap_base +
  geom_tile(aes(x = response, y = term, fill = estimate)) +
  scale_fill_gradientn(
    'Effect Size Estimate',
    colors = palette,
    limits = c(min_lim, max_lim),
    breaks = c(min_lim,  min_lim / 2, 0 , max_lim/2, max_lim)
  )

es_heatmap_clo

```

#### Adding dendrograms

Dendrograms can be added to cluster-ordered `ggplot2` plots, but it can be quite complicated. Dendrograms will be created using the `ggdendro` package. 

```{r}
library(ggdendro)
```

```{r}
# Extract dendrogram data from previous cluster results
dendro_dat <- segment(dendro_data(clust))
```

A basic dendrogram can be plotted quite easily.

```{r}
dendro <-
  ggplot(dendro_dat) +
  geom_segment(aes(x = x, y = y, xend=xend, yend=yend), colour = 'black') +
  theme_dendro()

dendro
```

The default dendrogram points down. To put the dendrogram on the left of our plot, we want it to point to the right. We can do this by switching the x and y coordinates.

```{r}
dendro <-
  ggplot(dendro_dat) +
  geom_segment(aes(x = -y, y = x, xend=-yend, yend=xend), colour = 'black') +
  theme_dendro()

dendro
```

We will use the `gridExtra` package to display our plots together. Though our dendrogram looks okay, there will be alignment issues when we first plot the dendrogram and heatmap side by side.

```{r, message=FALSE, warning=FALSE}
library(gridExtra)
```

```{r}
grid.arrange(dendro, es_heatmap_clo, ncol = 2, widths = c(3, 15))
```

As we can see, the dendrogram is not aligned with the heatmap labels. To get around this, we will use a hack; we will create an empty ggplot with the same scale and layout as the heatmap under the dendrogram. 

```{r}

# Takgin only the column with the longest label maintains alignment while
# simplifying plot layout
x_labels <- 
  plot_data_clo$response %>% 
  unique()

longest_x_label <-
  x_labels[[which.max(nchar(x_labels))]]

longest_x_label_data <-
  plot_data %>% 
  filter(response == longest_x_label)

```

```{r}
# Align the top of the dendrogram with the x-axis label
max_dendro <-
  max(abs(c(dendro_dat$y, dendro_dat$yend)))

offset <- max_dendro + 1
```

```{r}
dendro <-
  # empty ggplot with same x and y axis
  ggplot() +
  geom_blank(aes(x = response, y = term), data = longest_x_label_data) + 
  # Draw dendrogram
  geom_segment(aes(x = (-y + offset), y = x, xend=(-yend + offset), yend=xend),
               colour = 'black', 
               data = dendro_dat) +
  scale_x_discrete(position = 'top', expand = c(0, 0.02, 0, 0)) + 
  thm +
  theme(legend.position = 'none',
        axis.text.y = element_blank(),
        axis.text.x = element_text(colour = 'white'),
        panel.grid = element_blank(),
        panel.border = element_rect(fill = NA, colour = 'white')
  )  


grid.arrange(dendro, es_heatmap_clo, ncol = 2, widths = c(3, 15)) 
```

To better understand how this works, lets walk through it step by step. To make what is going on clearer, many layout elements will initially be left visible. We start by creating the empty plot with the same layout and scale as the heatmap.

```{r}
dendro <-
  # empty ggplot with same x and y axis
  ggplot() +
  geom_blank(aes(x = response, y = term), data = longest_x_label_data) + 
  scale_x_discrete(position = 'top') +
  # Match heatmap layoutt
  thm +
  # Remove unneeded text
  theme(axis.text.y = element_blank())

grid.arrange(dendro, es_heatmap_clo, ncol = 2, widths = c(3, 15)) 
```

Having matched the plot layout, the dendrogram will now align with the heatmap.

```{r}

max_dendro <-
  max(abs(c(dendro_dat$y, dendro_dat$yend)))

offset <- max_dendro + 1

dendro <-
  dendro + 
  geom_segment(aes(x = -y+offset, y = x, xend=-yend+offset, yend=xend),
               colour = 'black', 
               data = dendro_dat)

grid.arrange(dendro, es_heatmap_clo, ncol = 2, widths = c(3, 15)) 
```

When we add the dendrogram, we see that it is perfectly aligned to the heatmap labels. However, some of the dendrogram is outside the plotted area to the left. This issue can be rectified through the `expand` argument. The second argument to `expand` controls the space to the left of the plot, and needs to be large enough so that the whole dendrogram is visible. For dendrograms of default thickness, 0.02 is a near-perfect default. For dendrograms with thicker lines, the argument will need to be larger so that the whole dendrogram is plotted. (# Note the offset value calculated above corrects a situation where otherwise the best values to pass to `expand` require a lot of trial and error.)

```{r}

dendro <-
  dendro +
  scale_x_discrete(position = 'top', expand = c(0, 0.02, 0, 0)) 

grid.arrange(dendro, es_heatmap_clo, ncol = 2, widths = c(3, 15)) 
```

To finalize the plot, we make invisible the remaining non-essential layout elements.

```{r}
dendro <-
  dendro +
  theme(panel.grid = element_blank(),
        axis.text = element_text(color = 'white'),
        panel.border = element_rect(fill = NA, color = 'white'))

grid.arrange(dendro, es_heatmap_clo, ncol = 2, widths = c(3, 15)) 
```

### Side-by-side heatmaps

One might find it desirable to show a heatmap for both P-values and effect sizes at the same time. This can be done using the `gridExtra` package. When displaying heatmaps side by side, some visual elements will need to be changed and/or rearranged for optimal presentation.

```{r}

# 90 text and move legend belwow plot
multi_heatmap_thm <-
  thm + 
  theme(axis.text.x.top  = element_text(angle = 90),
        legend.position = 'bottom') 

# Put legend title on top of bar
cbg <-  guides(fill = guide_colorbar(title.position = 'top', barwidth = 15))

pv_heatmap_clo <-
  pv_heatmap_clo +
  multi_heatmap_thm +
  cbg +
  # Can only use regular text for legend title
  scale_fill_viridis_c('Negative Log10 P-value')

es_heatmap_clo <-
  es_heatmap_clo +
  multi_heatmap_thm +
  cbg

grid.arrange(pv_heatmap_clo, es_heatmap_clo, ncol = 2)

```


#### One set of Y-axis labels

If one wants a single set of y-axis labels for both heatmaps, it can get quite tricky. The naive solution of simply removing one set of y-axis labels does not work, as labels are considered a part of the plot area. Therefore when the heatmaps are plotted adjacent to one another, the heatmap with y-axis labels will appear smaller.

```{r}
es_heatmap_clo <-
  es_heatmap_clo +
  theme(axis.text.y = element_blank())

grid.arrange(pv_heatmap_clo, es_heatmap_clo, ncol = 2)
```

One solution is to create three different plots. Two heatmaps without y-axis labels, and one plot of text that will serve as the labels. This process is similar to that of adding a dendrograms to a plot. We will create an empty ggplot with the same scale and layout as the heatmaps to align the y-axis labels and heatmaps when they are plotted adjacent to one another.  

```{r}
pv_heatmap_clo <-
  pv_heatmap_clo +
  theme(axis.text.y = element_blank())
```

```{r}

labels <- 
  # Replicate heatmap layout
  ggplot(longest_x_label_data, aes(x = response, y = term)) + 
  multi_heatmap_thm +
  guides(color = guide_colorbar(title.position = 'top', frame.colour = 'white' )) +
  # Force a colorbar to be drawn to match layout, but add no text
  geom_text(aes(label = '', color = p.value)) +
  # Plot the text labels in black
  geom_text(aes(label = term), color = 'black', hjust = 'right', size = 5) +
  # Remove whitespace to left of text
  scale_x_discrete(position = 'top', expand = c(1, 0, 0, 0)) +
  # Make invisible the unnessecary plot layout
  guides(color = guide_colorbar(title.position = 'top', frame.colour = 'white' )) +
  scale_color_gradient(low = 'white', high = 'white') +
  theme(
    legend.text = element_text(colour = 'white'),
    legend.title = element_text(colour = 'white'),
    panel.grid = element_blank(),
    panel.border = element_rect(fill = NA, colour = 'white'),
    axis.text.x = element_text(colour = 'white'),
    axis.text.y = element_blank(),
  ) 



grid.arrange(labels, pv_heatmap_clo , es_heatmap_clo , 
             ncol = 3, 
             widths = c(1.3, 3, 3), # Best may take some trial and error
             padding = unit(0, 'line')) # Shift plots closer together
```


#### Adding dendrograms

To add a dendrogram to side-by-side heatmaps with one set of y-axis labels, we will employ the strategy we have used whenever we want to align adjacent plots; match the heatmap layout and then make it invisible to align and display the dendrogram.


```{r}


dendro <- 
  ggplot()  +
  # match layout
  geom_point(aes(x = response, y = term),
             colour = NA,
             data = longest_x_label_data) +
  multi_heatmap_thm +
  scale_x_discrete(position = 'top', expand = c(1, 0, 0, 0)) +
  
  # Force color bar to be drawn to match layout
  geom_segment(aes(x = -y + offset, y = x, xend= -yend + offset, yend=xend, color = x),
               data = dendro_dat) +
  # draw black dendrogram on top
  geom_segment(aes(x = -y + offset, y = x, xend= -yend + offset, yend=xend),
               colour = 'black', 
               data = dendro_dat) +
  # Make invisible the unnessecary plot layout
  guides(color = guide_colorbar(title.position = 'top', frame.colour = 'white' )) +
  scale_color_gradient(low = 'white', high = 'white') +
  theme(
    legend.text = element_text(colour = 'white'),
    legend.title = element_text(colour = 'white'),
    panel.grid = element_blank(),
    panel.border = element_rect(fill = NA, colour = 'white'),
    axis.text.x = element_text(colour = 'white'),
    axis.text.y = element_blank()
  )

```

```{r}
grid.arrange(dendro, labels, pv_heatmap_clo , es_heatmap_clo ,
             ncol = 4, 
             widths = c(.6, 0.8, 1.5, 1.5))
```



