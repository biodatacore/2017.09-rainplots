---
title: "Rainplots Tutorial"
author: "Mir Henglin"
date: "null"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.height = 10, fig.width = 10, fig.align = "center")
```

To construct rainplots in R, we will be using the `ggplot2` package. To perform data manipulation, we will be using the `dplyr` package.

```{r library, warning=FALSE, message=FALSE}
library(dplyr)
library(ggplot2)

```

```{r import,include=FALSE, message=FALSE, warning=FALSE}

plot_data <-
    readRDS('data/plotdat.rds') %>%
    mutate(estimate = round(estimate, 1)) %>%
    mutate(
        p_value_label = paste('-log10(p) = ', round(neg_log10_pvalue, 2)),
        beta_label = paste('b = ', estimate)
    )

plot_data <- plot_data %>% filter(rank %in% seq(1, 121, 6))

plot_data <- 
    plot_data %>%
    select(response, term, estimate, p.value)
```

## Data Format

Rainplots are useful for summarizing the results of multiple models at the same time. In order to plot those results in ggplot2, those results must formatted properly. Specifically, the data must be organized in a `data.frame` with columns indicating

* The model that the results came from
* The term that was evaluated
* The pvalue
* The regression estimate

An example of data organized in this way can be seen below.

```{r}
plot_data
```

In this dataset, `estimate` and `p.value` indicate the regression estimate and the p.value of that estimate. `term` indicates the ID of the metabolite included in the model. `response` indicates which model that a term corresponds to. For example If `response` = Body Mass Index, this indicates that the regression estimate and the p.value correspond to the model where Body Mass Index was the response variable.

## Plotting

Before plotting, we will first transform the p.value onto the log-scale. 

```{r}
plot_data <- 
    plot_data %>% 
    mutate(p.value = -1 * log10(p.value))
```

We can then construct a basic rainplot.

```{r}

rainplot <-
    plot_data %>%
    ggplot(aes(x = response, y = term)) +
    geom_point(aes(colour = estimate, size = p.value)) 

rainplot
```


This is a good start, but we will want to clean it up. We can do this by creating a custom ggplot2 theme.

```{r}

thm <- 
    theme_light(base_size = 18) +
    theme(
        axis.title.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.title.y = element_blank(),
        axis.ticks.y = element_blank(),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.line = element_blank(),
        legend.key = element_blank(),
        panel.background = element_rect(fill = 'white'),
        plot.background = element_rect(fill = 'white'),
        legend.background = element_rect(fill = 'white'),
        axis.text.x.top  = element_text(angle = 45, hjust = 0)
    ) 

rainplot <- rainplot + thm + scale_x_discrete(position = 'top')
rainplot


```

To make it easier to identify the terms that had small p.values in multiple models, we will convert the `term` variable into an ordered factor.


```{r}
term_order <-
    plot_data %>% 
    group_by(term) %>% 
    summarise(mpv = mean(p.value)) %>% 
    arrange(mpv) %>% 
    pull(term)

plot_data <- 
    plot_data %>% 
    mutate(term = factor(term, levels = term_order))
```

```{r}
rainplot <-
    plot_data %>%
    ggplot(aes(x = response, y = term)) +
    geom_point(aes(colour = estimate, size = p.value)) + 
    scale_x_discrete(position = 'top') +
    thm

rainplot
```


To make the presentation of the regresstion estimates clearer, we create a diverging color scale, and set positive and negative limits equidistant from 0.

```{r}

palette <-
    c("#053061",
      "#313695",
      "#4575b4",
      "#74add1",
      "#abd9e9",
      "#e0f3f8",
      # "#ffffbf",
      "#fee090",
      "#fdae61",
      "#f46d43",
      "#d73027",
      "#a50026",
      '#67001f')

max_abs <- max(abs(plot_data$estimate))

rainplot <- rainplot +
    scale_color_gradientn(
        colors = palette,
        limits = c(-1 * max_abs, max_abs),
        breaks = c(-1 * max_abs, -1 * max_abs / 2, 0 , max_abs/2, max_abs)
    )

rainplot


```


Another step to improve readability is to increase the maximum size of each bubble. There will be a bit of trial and error here; if the size threshold is too large, the bubbles will overlap.

```{r}
rainplot + 
    scale_size_area(max_size = 12)
```


Onoe possible issue is that we have a few `p.values` that are much larger than the others. When we plot the full range of the data, we lose resolution in the range where most of the data lies. One possible solution is to set all values above some ceiling, here chosen to be 15, to the value of the ceiling. 


```{r}

plot_data <- 
    plot_data %>% 
    mutate(p.value = ifelse(p.value > 15, 15, p.value))

rainplot <-
    plot_data %>%
    ggplot(aes(x = response, y = term)) +
    geom_point(aes(colour = estimate, size = p.value)) +
    scale_color_gradientn(
        colors = palette,
        limits = c(-1 * max_abs, max_abs),
        breaks = c(-1 * max_abs, -1 * max_abs / 2, 0 , max_abs/2, max_abs)
    ) +
    scale_size_area(max_size = 12, breaks = c(5, 10, 15), labels = c('5', '10', '>=15')) +
    scale_x_discrete(position = 'top') +
    thm

rainplot
```
